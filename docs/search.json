[
  {
    "objectID": "src/Forcaster_Explorer.html",
    "href": "src/Forcaster_Explorer.html",
    "title": "Forecaster Prediction Performance",
    "section": "",
    "text": "Code\n%%capture\nfrom tqdm import tqdm\nfrom convokit import Corpus, Speaker, Utterance\nfrom collections import defaultdict\nimport pandas as pd\nimport pprint as pp\nfrom IPython.display import display\nfrom modules.DataPreprocesser import DataPreprocesser\nfrom modules import CorpusUtils as corp\nimport torch\nimport pickle\n\n# Add the src directory to the path\nimport sys\nimport os\n\n# Add the src\nsys.path.append(os.path.abspath(\".\"))\nimport import_ipynb\n\n#Convokit Imports\nfrom convokit.forecaster.CRAFTModel import CRAFTModel\nfrom convokit.forecaster.forecaster import Forecaster\n\n\n\nTodo:\n\nFighting words for impasse and success disputes\nA paper from paper from Jonathan P. Cheng (Horizon paper) that preceeeds the CRAFT model defines pragmatic devices—such as politeness strategies and rhetorical prompts—used to start a conversation, and analyze their relation to its future trajectory.\n\nConvokit has a notebook (very recent-2025) that creates Prompt Types/politeness strategy labels for paired utterances to make derailement predicitons\n\nPlot utterances frequenices across context length dimension (averaged across all conversations)\ndownsample KODIS (balanced) -&gt; check performance\nfine-tune wiki on KODIS -&gt; check performance\n\n\n\nPerformance Considerations:\n\nIs the relative horizon (normalizing for conversation length) for forcasting derailement in KODIS disputes similar to the horizon for WIKI and CMV test dialogues?\nHow early is “good enough” for us?\nOur tokenized utterances are very short (avg.len 23) vs 84/123. Is our in-vitro dispute comprable to other dispute datasets or are these confounding factors influencing the length of negotiation utterances? Shorter utterances influence CRAFT’s performance significantly?\n\n\n\nCreating KODIS Corpus Object\n\nCreate Corpus\n\n\nCode\nfilepath = \"/Users/mishkin/Desktop/Research/Convo_Kit/ConvoKit_Disputes/data/preprocessed_dyads.csv\"\nfinal_data = DataPreprocesser(filepath)\ntest_corp= corp.corpusBuilder(final_data)\n\n\n/Users/mishkin/Desktop/Research/Convo_Kit/ConvoKit_Disputes/src/modules/DataPreprocesser.py:111: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value '1702723625' has dtype incompatible with float64, please explicitly cast to a compatible dtype first.\n  self.utterancesDF.loc[13988, 'timestamp']= '1702723625'\n\n\n2107\n\n\n27498it [00:00, 58402.13it/s]\n\n\n\n\nCode\ntest_corp.print_summary_stats()\n\n\nNumber of Speakers: 4214\nNumber of Utterances: 27498\nNumber of Conversations: 2107\n\n\n\n\nAdd conversation lengths as conversation metadata\n\n1 is “impasse”\n0 is “success”\n\n\n\nCode\nfor convo in test_corp.iter_conversations():\n    convo_len = len(convo.get_utterance_ids())  # Count utterances in the conversation\n    convo.add_meta(\"convo_len\", convo_len)      # Store as conversation-level metadata\n    some_convo = test_corp.get_conversation(\"utt0_con0\")\nprint(\"Length of conversation:\", some_convo.retrieve_meta(\"convo_len\"))\n\n\nLength of conversation: 14\n\n\n\n\nAdd Conversation Labels from Final Pre-processed Dataframe as conversation metadata\n\n\nCode\nfor idx, row in final_data.getDataframe().iterrows():\n    convo_id = f\"utt0_con{idx}\"  # generate conversation_id format from index\n    label = row[\"dispute_outcome\"]  # update if your label column is named differently\n    if convo_id in test_corp.conversations:\n        test_corp.get_conversation(convo_id).meta[\"label\"] = label\n\n\n\n\n\nCreating Forecaster and Model Objects\n\nCMV Model and Forecaster Object for KODIS\n\n\nCode\n%%capture \nmodel2 = CRAFTModel(\n    initial_weights= \"craft-cmv-finetuned\",  # or \"craft-wiki-finetuned\"\n    torch_device=\"cuda\" if torch.cuda.is_available() else \"cpu\"\n)\n\n\n\n\nCode\n# Use 'label' because we added it to conversation.meta[\"label\"]\nforecaster2 = Forecaster(\n    forecaster_model=model2,\n    labeler=\"label\",  # uses conversation.meta[\"label\"]\n    forecast_attribute_name=\"prediction\",\n    forecast_prob_attribute_name=\"pred_score\"\n)\n\n\n\n\nWiki Model and Forecaster Object for KODIS\n\n\nCode\n%%capture \nmodel = CRAFTModel(\n    initial_weights= \"craft-wiki-finetuned\",  # or \"craft-wiki-finetuned\"\n    torch_device=\"cuda\" if torch.cuda.is_available() else \"cpu\"\n)\n\n\n\n\nCode\n# Use 'label' because we added it to conversation.meta[\"label\"]\nforecaster = Forecaster(\n    forecaster_model=model,\n    labeler=\"label\",  # uses conversation.meta[\"label\"]\n    forecast_attribute_name=\"prediction\",\n    forecast_prob_attribute_name=\"pred_score\"\n)\n\n\n\n\nForcaster Object for CMV and WIKI\n\n\nCode\nforecaster_cmv = Forecaster(\n    forecaster_model=model2,\n    labeler=\"has_removed_comment\",  # uses conversation.meta[\"label\"]\n    forecast_attribute_name=\"prediction\",\n    forecast_prob_attribute_name=\"pred_score\"\n)\n\nforecaster_wiki = Forecaster(\n    forecaster_model=model,\n    labeler=\"conversation_has_personal_attack\",  # uses conversation.meta[\"label\"]\n    forecast_attribute_name=\"prediction\",\n    forecast_prob_attribute_name=\"pred_score\"\n)\n\n\n\n\n\nModel Weight Info\n\ncraft‑pretrained\n\nContains only the utterance and context encoder layers pre‑trained on the CGA‑Wikipedia or CGA-CMV data (via next‑comment prediction), but its classifier head (the SingleTargetClf) is still at its random initialization.\nIntended as a starting point if you want to fine‑tune CRAFT on your own conversational data (you’ll call fit to learn the classifier weights).\n\n\n\ncraft‑finetuned (used)\n\nBuilds on the above by having already fine‑tuned the entire network (including the classifier head).\nReady for inference only—you can call transform immediately and get sensible forecasts without any further training.\n\n\n\nCode\ndisplay(model._config)\n\n\n{'dropout': 0.1,\n 'batch_size': 64,\n 'clip': 50.0,\n 'learning_rate': 1e-05,\n 'print_every': 10,\n 'finetune_epochs': 30,\n 'validation_size': 0.2}\n\n\n\n\n\nComparing fine-tuned Models on KODIS Corpus\n\nRunning predictions on both fine-tuned wiki and cmv CRAFT models temporally on all utterances\n\n\nCode\n%%capture \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import roc_auc_score, accuracy_score, f1_score\n\n\n# corpusBuilder should return a ConvoKit Corpus\ncorp1 = corp.corpusBuilder(final_data)\ncorp2 = corp.corpusBuilder(final_data)\n\n# Assign conversation-level labels\nfor idx, row in final_data.getDataframe().iterrows():\n    convo_id = f\"utt0_con{idx}\"\n    label = row[\"dispute_outcome\"]\n    if convo_id in corp1.conversations:\n        corp1.get_conversation(convo_id).meta[\"label\"] = label\n    if convo_id in corp2.conversations:\n        corp2.get_conversation(convo_id).meta[\"label\"] = label\n\n# # 2. Initialize two forecasters with different CRAFT weights\n# device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n# craft_wiki = CRAFTModel(\"craft-wiki-finetuned\", torch_device=device)\n# craft_cmv  = CRAFTModel(\"craft-cmv-finetuned\",  torch_device=device)\n# forecaster1 = Forecaster(craft_wiki, \"label\")\n# forecaster2 = Forecaster(craft_cmv,  \"label\")\n\n\n\n# 4. Transform both corpora\ncorp1 = forecaster.transform(corp1)\ncorp2 = forecaster2.transform(corp2)\n\n\n\n\nGetting average derailement prediction and frequency of forecast probabilities across all utterances\n\nPrediciton is per utterance on surface, but CRAFT model behind-the-scenes makes predicitons on encoded contexts which contain the conversation history up to current utterance.\nSee Predictor Class in runnery.py for CRAFT model\nWe get the frequency of KODIS utterances across 50 probabilities [0, .02, .04, …,1] binned from the predicited probabilities of each utterance by the fine-tuned cmv and fine-tuned wiki model\n\n\n\nInsights\n\ncraft-wiki tends to\n\nTODO Make 3D plot, add another dimension for the length of current context (collapse by coversation by averaging over all convos that have that context length)\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import roc_auc_score, accuracy_score, f1_score\n\n# 1) extract the utterance‑level DataFrames from the two corpora\nutt_df1 = corp1.get_utterances_dataframe()\nutt_df2 = corp2.get_utterances_dataframe()\n\n\n# 5. Keep only the forecast columns and drop NA\nforecast_df1 = utt_df1[['meta.prediction', 'meta.pred_score']].dropna()\nforecast_df2 = utt_df2[['meta.prediction', 'meta.pred_score']].dropna()\n\n# 6. Summary statistics\nsummary = pd.DataFrame({\n    'mean_prob':  [forecast_df1['meta.pred_score'].mean(),  forecast_df2['meta.pred_score'].mean()],\n    'std_prob':   [forecast_df1['meta.pred_score'].std(),   forecast_df2['meta.pred_score'].std()],\n    'median_prob':[forecast_df1['meta.pred_score'].median(),forecast_df2['meta.pred_score'].median()],\n}, index=['corp-wiki', 'corp-cmv'])\nprint(\"Summary statistics for forecast probabilities:\")\nprint(summary)\n\n# 7. Plot histograms\nplt.figure(figsize=(8,4))\nplt.hist(forecast_df1['meta.pred_score'], bins=50, alpha=0.6, label='craft-wiki')\nplt.hist(forecast_df2['meta.pred_score'], bins=50, alpha=0.6, label='craft-cmv')\nplt.xlabel('Forecast Derailment probability')\nplt.ylabel('Number of Utterances')\nplt.legend()\nplt.show()\n\n\nSummary statistics for forecast probabilities:\n           mean_prob  std_prob  median_prob\ncorp-wiki   0.440724  0.267856     0.381885\ncorp-cmv    0.541044  0.271951     0.528305\n\n\n\n\n\n\n\n\n\n\n\nConversation-level AUC and PR Curves\nto create these plots, I looked at Forecasters code for aggregating utternce-levele metrics on a conversation level where:\n\nnp.max(forecast_scores) is highest probability the model ever assigned to any utterance in this conversation\nnp.max(forecasts) is if the model ever cross its decision threshold and predict 1 (derailement) for thsi conversation\n\n\n\nInsights\n\nBaseline positive class rate (impasse dispute) for KODIS is 17.6% out of current 2107 disputes.\n\nPR Curve\n\nBottoms out at baseline impasse rate with lower decision thresholds. Essesntially, as I lower decision threshold (less confident about classifying impasse) -&gt; it mispredicts impasse a lot more for successful conversations since higher recall -&gt; less chance of 0(success) outcome. Therefore, model is as good as random classifier as it predicts the baseline derailment rate from the sample. Probably due to high impassee/success class imbalance.\nwiki model outperforms cmv model acrosss all decision thresholds, so it does better overall with getting successful disputes right\n\nAUC Curve\n\nAUC still looks high for both bc of the class imbalance for derailement disputes I think– so this may be misleading currently\n\nneed to downsample and check if we do better than random\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import roc_curve, precision_recall_curve, auc\nimport numpy as np\n\ndef get_conv_level_scores(corpus):\n    # 1) grab all utterances with a forecast\n    utt = (corpus\n            .get_utterances_dataframe()[['conversation_id','meta.pred_score']]\n            .dropna())\n    conv_scores = utt.groupby('conversation_id')['meta.pred_score'].max()\n    conv_df = corpus.get_conversations_dataframe()\n    conv_scores = conv_scores.reindex(conv_df.index, fill_value=0)\n    y_true = conv_df['meta.label'].astype(int)\n    y_scores = conv_scores.values\n    return y_true, y_scores\n\ndef print_baseline_accuracy(corpus, label_field=\"label\"):\n    # pull out the conversation‑level labels\n    conv_df = corpus.get_conversations_dataframe()[[f\"meta.{label_field}\"]]\n    \n    # count each class\n    counts = conv_df[\"meta.label\"].value_counts()\n    min_label = counts.idxmin()    \n    min_count = counts.min()      \n    total     = counts.sum()\n    baseline_acc = min_count / total\n    print(f\"Baseline accuracy (derailement): {baseline_acc:.3f}\")\n    \n\n\nconv_df = corp1.get_conversations_dataframe()[[f\"meta.label\"]]\ndisplay(conv_df[\"meta.label\"].value_counts())\ny1, s1 = get_conv_level_scores(corp1)\ny2, s2 = get_conv_level_scores(corp2)\n\npositive_rate = np.mean(y1)\nprint(f\"Positive class rate (Derailement): {positive_rate:.2%}\")\nprint_baseline_accuracy(corp1)\n\n# compute ROC and PR metrics\nfpr1, tpr1, _    = roc_curve(y1, s1)\nroc_auc1         = auc(fpr1, tpr1)\nfpr2, tpr2, _    = roc_curve(y2, s2)\nroc_auc2         = auc(fpr2, tpr2)\n\nprec1, rec1, _   = precision_recall_curve(y1, s1)\npr_auc1          = auc(rec1, prec1)\nprec2, rec2, _   = precision_recall_curve(y2, s2)\npr_auc2          = auc(rec2, prec2)\n\n# plot side‑by‑side\nfig, (ax_roc, ax_pr) = plt.subplots(1, 2, figsize=(12,5))\n\n# ROC panel\nax_roc.plot(fpr1, tpr1, label=f'corp-wiki (AUC={roc_auc1:.3f})')\nax_roc.plot(fpr2, tpr2, label=f'corp-cmv (AUC={roc_auc2:.3f})')\nax_roc.set_xlabel('False Positive Rate')\nax_roc.set_ylabel('True Positive Rate')\nax_roc.set_title('ROC Curves')\nax_roc.legend()\n\n# PR panel\nax_pr.plot(rec1, prec1, label=f'corp-wiki (AUC={pr_auc1:.3f})')\nax_pr.plot(rec2, prec2, label=f'corp-cmv (AUC={pr_auc2:.3f})')\nax_pr.set_xlabel('Recall')\nax_pr.set_ylabel('Precision')\nax_pr.set_title('Precision–Recall Curves')\nax_pr.legend()\n\nplt.tight_layout()\nplt.show()\n\n\nmeta.label\n0    1736\n1     371\nName: count, dtype: int64\n\n\nPositive class rate (Derailement): 17.61%\nBaseline accuracy (derailement): 0.176\n\n\n\n\n\n\n\n\n\n\n\nComparing forcaster summaries for both fine-tuned wiki and cmv CRAFT models predictions\n\nRan using Forecasters summarize function for conversation-level statistics\nboth reddit and cmv have Utterance-level labels for derailed comment as well as classify derailment on a conversation level if the conversation contains a derailement comment.\n\n\n\nInsights\nForecast Horizon: “How early can we detect derailement?”\n\nThis measures the number of utterances after the derailed utterance the model predicted in a coversation.\nSince our dataset has an average length of 13.5 utterances, the forecast horizon on average is 9.72 and 10 respecitvely for the WIKI and cmv models, meaning derailement is forecast towards the end of a KODIS dispute.\n\nConversation Metrics - On a conversation-level, accuracy of predicting derailement is pretty low and F1 scores are low for both fine-tuned models\n\nAccuracy: The model mispredicts derailements most of the time (for success class mainly) - out of 2017 disputes, 45% and 24% were wrongly flagged as derailed. -&gt; low Accuracy\nRecall: Models are very sensitive to derailement events and for all actual derailed disputes, it correctly flags them -&gt; high Recall\nFPR: Since there are many successul disputes (majority class), the models flag a lot of them as derailed -&gt; high FPR\n\nCalibration Curves\n\nboth models underperform\n\nThe above is why the “good” AUC curve is misleading I think\n\n\nCode\n%%capture\nimport numpy as np\nimport matplotlib.pyplot as plt\nhorizon_kwiki = forecaster._draw_horizon_plot(corp1)\nhorizon_kcmv  = forecaster2._draw_horizon_plot(corp2)\nconv_kwiki, metrics1_kwiki = forecaster.summarize(corp1)\nconv_kcmv, metrics2_kcmv = forecaster2.summarize(corp2)\n\n\n\n\nCode\nimport pandas as pd\nfrom IPython.display import display\n\nlengths = [\n    len(convo.get_utterance_ids())\n    for convo in corp2.iter_conversations()\n]\navg_len = sum(lengths) / len(lengths)\nprint(f\"Average conversation length in KODIS is: {avg_len:.2f} utterances\")\n\nprint(\"\\n-------------------\")\nprint(\"OVERALL STATS FOR KODIS PREDICTIONS \\n-------------------\")\nmetrics_df = pd.DataFrame([metrics1_kwiki, metrics2_kcmv], index=['model_wiki','model_cmv'])\ndisplay(metrics_df)\n\n\nvals_kwiki = np.array(list(horizon_kwiki.values()))\nvals_kcmv  = np.array(list(horizon_kcmv.values()))\n\nmax_kwiki = vals_kwiki.max() if vals_kwiki.size else 1\nmax_kcmv  = vals_kcmv.max()  if vals_kcmv.size  else 1\n\nbins_kwiki = range(1, max_kwiki)\nbins_kcmv  = range(1, max_kcmv)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,4), sharey=True)\n\nax1.hist(vals_kwiki, bins=bins_kwiki, density=True, edgecolor=\"k\")\nax1.set_title(\"Wiki model\\nForecast horizon\")\nax1.set_xlabel(\"Number of comments between first positive\\nforecast and end of conversation\")\nax1.set_ylabel(\"Percent of conversations\")\n\nax2.hist(vals_kcmv, bins=bins_kcmv, density=True, edgecolor=\"k\")\nax2.set_title(\"CMV model\\nForecast horizon\")\nax2.set_xlabel(\"Number of comments between first positive\\nforecast and end of conversation\")\ndisplay(\"wiki model horizon stats:  Mean = 9.723837209302326, Median = 9.0\")\ndisplay(\"cmv model horizon stats: Mean = 10.006060606060606, Median = 9.0\")\nplt.tight_layout()\nplt.show()\n\n\n# 3) Merge the two conversation‐level forecasts side by side\nconv1 = conv_kwiki.rename(columns={'label':'label','score':'score_wiki','forecast':'forecast_wiki'})\nconv2 = conv_kcmv.rename(columns={'score':'score_cmv','forecast':'forecast_cmv'})\n\n# join on conversation_id\nmerged = conv1.join(conv2[['score_cmv','forecast_cmv']], how='inner')\n# print(\"=== Conversation‑level forecasts comparison ===\")\n# display(merged)\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\nfrom sklearn.calibration import CalibrationDisplay\nfrom IPython.display import display\n\n\n# 1) Compute agreement flag\nmerged['match'] = merged['forecast_wiki'] == merged['forecast_cmv']\n\n# 2) Overall agreement rate\nagree_rate = merged['match'].mean()\nprint(f\"Agreement rate between wiki vs. cmv predictions: {agree_rate:.2%}\\n\")\n\n# 3) Where they disagree\nprint(\"Disagreement breakdown (wiki  vs. cmv ):\")\nprint(pd.crosstab(\n    merged.loc[~merged['match'], 'forecast_wiki'],\n    merged.loc[~merged['match'], 'forecast_cmv'],\n    rownames=['wiki_pred'], colnames=['cmv_pred']\n))\nprint(\"\\n\")\n\n# 4) Calibration + histogram side by side\nfig, (ax_cal, ax_hist) = plt.subplots(1, 2, figsize=(12, 4))\n\n# 4a) overlayed calibration curves on the left\nCalibrationDisplay.from_predictions(\n    y_true=merged['label'],\n    y_prob=merged['score_wiki'],\n    n_bins=10,\n    name=\"Wiki\",\n    ax=ax_cal\n)\nCalibrationDisplay.from_predictions(\n    y_true=merged['label'],\n    y_prob=merged['score_cmv'],\n    n_bins=10,\n    name=\"CMV\",\n    ax=ax_cal\n)\nax_cal.set_title(\"Calibration Curve (Reliability)\")\nax_cal.set_xlabel(\"Mean predicted probability\")\nax_cal.set_ylabel(\"Observed fraction\")\nax_cal.legend(loc=\"lower right\")\nax_cal.grid(True)\n\n# 4b) probability‐histogram on the right\nbins = np.linspace(0, 1, 11)\nax_hist.hist(merged['score_wiki'], bins=bins, alpha=0.6, label='Wiki')\nax_hist.hist(merged['score_cmv'],  bins=bins, alpha=0.6, label='CMV')\nax_hist.set_title(\"Probability Histogram\")\nax_hist.set_xlabel(\"Predicted probability\")\nax_hist.set_ylabel(\"Count of utterances\")\nax_hist.legend()\nax_hist.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n# 5) Confusion matrices side by side\nfig, (ax_wiki, ax_cmv) = plt.subplots(1, 2, figsize=(10, 4))\n\nConfusionMatrixDisplay.from_predictions(\n    y_true=merged['label'],\n    y_pred=merged['forecast_wiki'],\n    display_labels=[\"Success\", \"Impasse\"],\n    cmap='Blues',\n    ax=ax_wiki\n)\nax_wiki.set_title(\"Wiki Model\")\n\nConfusionMatrixDisplay.from_predictions(\n    y_true=merged['label'],\n    y_pred=merged['forecast_cmv'],\n    display_labels=[\"Success\", \"Impasse\"],\n    cmap='Blues',\n    ax=ax_cmv\n)\nax_cmv.set_title(\"CMV Model\")\n\nplt.tight_layout()\nplt.show()\n\n# 6) Summary table\nsummary = pd.DataFrame({\n    'wiki_acc':       [(merged['label'] == merged['forecast_wiki']).mean()],\n    'cmv_acc':        [(merged['label'] == merged['forecast_cmv']).mean()],\n    'agreement_rate': [agree_rate],\n    'wiki_avg_prob':  [merged['score_wiki'].mean()],\n    'cmv_avg_prob':   [merged['score_cmv'].mean()],\n}, index=['utterance_level'])\nprint(\"\\nSummary statistics:\")\ndisplay(summary)\n\n\n\nAverage conversation length in KODIS is: 13.05 utterances\n\n-------------------\nOVERALL STATS FOR KODIS PREDICTIONS \n-------------------\n\n\n\n\n\n\n\n\n\nAccuracy\nPrecision\nRecall\nFPR\nF1\n\n\n\n\nmodel_wiki\n0.450403\n0.233220\n0.927224\n0.651498\n0.372698\n\n\nmodel_cmv\n0.240152\n0.174603\n0.889488\n0.898618\n0.291906\n\n\n\n\n\n\n\n'wiki model horizon stats:  Mean = 9.723837209302326, Median = 9.0'\n\n\n'cmv model horizon stats: Mean = 10.006060606060606, Median = 9.0'\n\n\n\n\n\n\n\n\n\nAgreement rate between wiki vs. cmv predictions: 69.96%\n\nDisagreement breakdown (wiki  vs. cmv ):\ncmv_pred   0.0  1.0\nwiki_pred          \n0.0          0  524\n1.0        109    0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSummary statistics:\n\n\n\n\n\n\n\n\n\nwiki_acc\ncmv_acc\nagreement_rate\nwiki_avg_prob\ncmv_avg_prob\n\n\n\n\nutterance_level\n0.450403\n0.240152\n0.699573\n0.708614\n0.801742\n\n\n\n\n\n\n\n\n\nCode\nprint(merged['label'].value_counts())\nprint(merged['forecast_wiki'].value_counts())\nprint(merged['forecast_cmv'].value_counts())\n\n\nlabel\n0    1736\n1     371\nName: count, dtype: int64\nforecast_wiki\n1.0    1475\n0.0     632\nName: count, dtype: int64\nforecast_cmv\n1.0    1890\n0.0     217\nName: count, dtype: int64\n\n\n\n\nAverage length of tokenized utterances for wiki test , cmv test, and kodis corpora from CRAFT tokenization scheme\n\nCRAFT has max tokenization length of 80 tokens per utterance. Is this relevant to the performance in anyway? More specifically:\n\nwhat are the tokenization lengths of the utterances for the data used in the train sets for CMV and Wiki?\nwhat is the average tokenization length for a KODIS utterance?\n\n\nIs it even relevant to affecting performance, and how to measure this?\n\n\nCode\nfrom convokit import download, Corpus\n\n\ncorpus_cmv = Corpus(\"/Users/mishkin/Desktop/Research/Convo_Kit/ConvoKit_Disputes/data/convokit_datasets/conversations-gone-awry-cmv-corpus\")\ncorpus_wiki = Corpus(\"/Users/mishkin/Desktop/Research/Convo_Kit/ConvoKit_Disputes/data/convokit_datasets/conversations-gone-awry-corpus\")\n\n\n\n\nCode\nconvo_ex =  next(corpus_wiki.iter_conversations())\nprint(\"Conversation Meta data for wiki conversation \\n\"\n\"======================\")\nfor key, val in convo_ex.meta.items():\n  \n    print(f\"{key:20s} → {val}\")\n\n\nprint(\"\\n\")\nconvo_ex2 =  next(corpus_cmv.iter_conversations())\nprint(\"Conversation Meta data for cmv conversation \\n \"\n\"======================\")\nfor key, val in convo_ex2.meta.items():\n    print(f\"{key:20s} → {val}\")\n\n\nConversation Meta data for wiki conversation \n======================\npage_title           → User talk:2005\npage_id              → 1003212\npair_id              → 143890867.11926.11926\nconversation_has_personal_attack → False\nverified             → True\npair_verified        → True\nannotation_year      → 2018\nsplit                → train\n\n\nConversation Meta data for cmv conversation \n ======================\npair_id              → cue8uxd\nhas_removed_comment  → True\nsplit                → train\nsummary_meta         → []\n\n\n\n\nCode\nimport os\nimport numpy as np\nfrom convokit import download, Corpus\nfrom convokit.forecaster.CRAFT.data import (\n    loadPrecomputedVoc,\n    tokenize,\n    Voc,\n)\n\n'''\nNeed to get only the utterances used for training fine-tuned model. \nChoose only those utterances in conversations where mete.split == train\n'''\n\ndef load_craft_vocab(model_name: str) -&gt; Voc:\n    base = download(model_name, data_dir=os.path.expanduser(\"~/.convokit/models\"))\n    return loadPrecomputedVoc(\n        model_name,\n        os.path.join(base, \"word2index.json\"),\n        os.path.join(base, \"index2word.json\"),\n    )\n\n\nvoc_wiki = load_craft_vocab(\"craft-wiki-finetuned\")\nvoc_cmv  = load_craft_vocab(\"craft-cmv-finetuned\")\n\n\n\n\nCode\n\"\"\"\n    Walk through all conversations in `corpus`, select only those with\n    convo.meta[\"split\"] == split, tokenize each utterance via CRAFT's\n    tokenize(voc, text), and return summary stats on token counts.\n\"\"\"\n\ndef summarize_token_lengths(corpus: Corpus, voc: Voc, split: str = None):\n    lengths = []\n    for convo in corpus.iter_conversations():\n        # if a split is specified, filter; otherwise include everything\n        if split is not None and convo.meta.get(\"split\") != split:\n            continue\n        for utt in convo.iter_utterances():\n            toks = tokenize(voc, utt.text or \"\")\n            lengths.append(len(toks))\n    if not lengths:\n        return {\"n_utt\": 0, \"mean\": np.nan, \"median\": np.nan, \"std\": np.nan}\n    arr = np.array(lengths)\n    return {\n        \"n_utt\":  int(arr.size),\n        \"mean\":   float(arr.mean()),\n        \"median\": float(np.median(arr)),\n        \"std\":    float(arr.std()),\n    }\n\n\n\n# -- 5) run it on all four settings --\nresults = {\n    \"craft‑wiki\":   summarize_token_lengths(corpus_wiki, voc_wiki, split=\"train\"),\n    \"craft‑cmv\":    summarize_token_lengths(corpus_cmv,  voc_cmv,  split=\"train\"),\n    \"kodis‑wiki\":   summarize_token_lengths(corp1, voc_wiki),\n    \"kodis‑cmv\":    summarize_token_lengths(corp1, voc_cmv),\n\n}\n\ndf = pd.DataFrame(results).T.reset_index().rename(columns={\"index\":\"vocab\"})\ndisplay(df)\n\n\n\n\n\n\n\n\n\nvocab\nn_utt\nmean\nmedian\nstd\n\n\n\n\n0\ncraft‑wiki\n18042.0\n82.001330\n47.0\n139.549799\n\n\n1\ncraft‑cmv\n25885.0\n123.472474\n72.0\n166.329963\n\n\n2\nkodis‑wiki\n27498.0\n24.159939\n20.0\n20.964779\n\n\n3\nkodis‑cmv\n27498.0\n24.159939\n20.0\n20.964779\n\n\n\n\n\n\n\n\n\n\nCompare Predictions on test sets for CMV and WIKI datasets using respecitve fine-tuned CRAFT Models\n\nfor reproducability, need to check if any additions since 2018 for wiki data as it is public and growing. reddit cmv was created specifically for this paper, so no updates expected.\n\n\n\nCode\ndef transform_selector(context_tuple):\n    \"\"\"\n    For transform we only need to check that the conversation is in the test split\n    \"\"\"\n    return (context_tuple.current_utterance.get_conversation().meta[\"split\"] == \"test\")\n\ncorpus_cmv = Corpus(\"/Users/mishkin/Desktop/Research/Convo_Kit/ConvoKit_Disputes/data/convokit_datasets/conversations-gone-awry-cmv-corpus\")\ncorpus_wiki = Corpus(\"/Users/mishkin/Desktop/Research/Convo_Kit/ConvoKit_Disputes/data/convokit_datasets/conversations-gone-awry-corpus\")\n\n\n\n\nCode\ncorp_test_wiki = forecaster_wiki.transform(corpus_wiki, context_selector= transform_selector)\ncorp_test_cmv = forecaster_cmv.transform(corpus_cmv, context_selector= transform_selector)\n\n\n\n\nCode\n%%capture\nimport numpy as np\nimport matplotlib.pyplot as plt\ntest_selector = lambda c: c.meta.get(\"split\") == \"test\"\nhorizon_wiki = forecaster_wiki._draw_horizon_plot(corp_test_wiki, test_selector)\nhorizon_cmv  = forecaster_cmv._draw_horizon_plot(corp_test_cmv, test_selector)\nconv_df1, metrics1 = forecaster_wiki.summarize(corp_test_wiki,  lambda c: c.meta['split'] == \"test\")\nconv_df2, metrics2 = forecaster_cmv.summarize(corp_test_cmv,  lambda c: c.meta['split'] == \"test\")\n\n\n\n\nCode\n\nlengths_cmv = [\n    len(convo.get_utterance_ids())\n    for convo in corp_test_cmv.iter_conversations()\n]\nlengths_wiki = [\n    len(convo.get_utterance_ids())\n    for convo in corp_test_wiki.iter_conversations()\n]\navg_len_cmv = sum(lengths_cmv) / len(lengths_cmv)\navg_len_wiki = sum(lengths_wiki) / len(lengths_wiki)\nprint(f\"Average conversation length in test WIKI is: {avg_len_wiki:.2f} utterances\")\nprint(f\"Average conversation length in test CMV is: {avg_len_cmv:.2f} utterances\")\nprint(\"\\n-------------------\")\nprint(\"OVERALL STATS FOR TEST SET PREDICTIONS \\n -------------------\")\nmetrics_df = pd.DataFrame([metrics1, metrics2], index=['corp_wiki_test','copr_cmv_test'])\ndisplay(metrics_df)\n\n\nvals_wiki = np.array(list(horizon_wiki.values()))\nvals_cmv  = np.array(list(horizon_cmv.values()))\n\nmax_wiki = vals_wiki.max() if vals_wiki.size else 1\nmax_cmv  = vals_cmv.max()  if vals_cmv.size  else 1\n\nbins_wiki = range(1, max_wiki)\nbins_cmv  = range(1, max_cmv)\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,4), sharey=True)\n\nax1.hist(vals_wiki, bins=bins_wiki, density=True, edgecolor=\"k\")\nax1.set_title(\"Wiki model\\nForecast horizon\")\nax1.set_xlabel(\"Number of comments between first positive\\nforecast and end of conversation\")\nax1.set_ylabel(\"Percent of conversations\")\n\nax2.hist(vals_cmv, bins=bins_cmv, density=True, edgecolor=\"k\")\nax2.set_title(\"CMV model\\nForecast horizon\")\nax2.set_xlabel(\"Number of comments between first positive\\nforecast and end of conversation\")\n\nplt.tight_layout()\nplt.show()\n\n\nAverage conversation length in test WIKI is: 7.17 utterances\nAverage conversation length in test CMV is: 6.28 utterances\n\n-------------------\nOVERALL STATS FOR TEST SET PREDICTIONS \n -------------------\n\n\n\n\n\n\n\n\n\nAccuracy\nPrecision\nRecall\nFPR\nF1\n\n\n\n\ncorp_wiki_test\n0.704762\n0.638264\n0.945238\n0.535714\n0.761996\n\n\ncopr_cmv_test\n0.620614\n0.589967\n0.790936\n0.549708\n0.675828"
  }
]